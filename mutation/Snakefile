import pandas as pd
from itertools import product
from itertools import chain
from dataclasses import dataclass
from typing import List

configfile: "config.json"

class Child:
	sample_id: str
	father_id: str
	mother_id: str
	father_regions: List[str]
	mother_regions: List[str]

	def __init__(self, sample_id: str):
		self.sample_id = sample_id
		self.father_id = None
		self.mother_id = None
		self.father_regions = {}
		self.mother_regions = {}

	def name_parent(self, parent_id: str, parent_type: str):
		if parent_type == 'father':
			if not self.father_id:
				self.father_id = parent_id
		elif parent_type == 'mother':
			if not self.mother_id:
				self.mother_id = parent_id

	def add_parent_region(self, parent_type: str, region: str, vcf: str):
		if parent_type == 'father':
			self.father_regions[region] = vcf
		elif parent_type == 'mother':
			self.mother_regions[region] = vcf

	def check_for_region(self, parent_type: str, region:str):
		if parent_type == 'father':
			if region in self.father_regions:
				return True
		elif parent_type == 'mother':
			if region in self.mother_regions:
				return True

		return False

	def return_vcf(self, parent_type: str, region:str):
		if parent_type == 'father':
			return self.father_regions[region]
		elif parent_type == 'mother':
			return self.mother_regions[region]
		else:
			raise KeyError(f'invalid child/parent/region combo: {self.sample_id} {parent_type} {region}')

	def get_parent_id(self, parent_type: str):
		if parent_type == 'father':
			return self.father_id
		elif parent_type == 'mother':
			return self.mother_id
		else:
			raise KeyError(f'something is wrong with your wildcards, parent is: {parent_type}')

	def __repr__(self) -> str:
		return self.sample_id


MANIFEST = config["manifest"]

platforms = ['hifi', 'ont']

manifest_df = pd.read_csv(MANIFEST, sep="\t", low_memory=False, header=0, dtype=str, keep_default_na=False)

parents = ['father', 'mother']
regions = []
child_dict = {}

for idx, row in manifest_df.iterrows():
	sample = row['sample']
	parent = row['parent_type']
	region = row['region']

	if sample not in child_dict:
		child_dict[sample] = Child(sample)

	child_dict[sample].name_parent(row['parent_id'], parent)
	child_dict[sample].add_parent_region(parent, region, row['vcf'])
	regions.append(region)

regions = list(set(regions))
samples = child_dict.keys()


def get_parent(wildcards):
	if wildcards.parent == 'father':
		return child_dict[f"{wildcards.family}_{wildcards.sample}"].father_id
	elif wildcards.parent == 'mother':
		return child_dict[f"{wildcards.family}_{wildcards.sample}"].mother_id


def filter_children(*args, **kwargs):
	for wc_comb in product(*args, **kwargs):
		sample = wc_comb[0][1]
		parent = wc_comb[1][1]
		region = wc_comb[2][1]

		if child_dict[sample].check_for_region(parent, region):
			yield(wc_comb)

localrules: all

rule all:
	input:
			expand("read_data/{sample}_from_{parent}.{region}.{platform}.validation.tsv", filter_children, sample = samples, parent = parents, region = regions, platform = platforms),
			expand("validated_calls/{sample}_from_{parent}.{region}.validated_snvs.tsv", filter_children, sample = samples, parent = parents, region = regions)

rule make_input_file:
	input:
		vcf = lambda wildcards: child_dict[f"{wildcards.sample}"].return_vcf(f"{wildcards.parent}", f"{wildcards.region}")
	output:
		snv_calls = "snv_calls/{sample}_from_{parent}.{region}.snvs.tsv"
	log:
		"log/format_calls_{sample}_from_{parent}.{region}.log"
	params:
		sample = "{sample}"
	resources:
		mem = 2,
		hrs = 2
	shell: """

		grep -v "#" {input.vcf}| \
			awk -v s={params.sample} '{{if(length($4)==length($5)) print $1, $2, s"_"$1"_"$2"_"$4"_"$5, $4, $5, $6, $7, $8, $9, $10}}' | \
			sed 's/ /\t/g' > {output.snv_calls}

	"""


rule get_snv_depth:
	input:
		snv_calls = "snv_calls/{sample}_from_{parent}.{region}.snvs.tsv"
	output:
		depth_stats = "read_data/{sample}_from_{parent}.{region}.{platform}.read_data.tsv",
		read_summary = "read_data/{sample}_from_{parent}.{region}.{platform}.read_summary.tsv"
	log:
		"log/read_data_{sample}_from_{parent}_{region}_{platform}.log"
	params:
		parent = "{parent}",
		platform = "{platform}",
		region = "{region}",
		child = "{sample}",
		bam_manifest = MANIFEST
	resources:
		mem = 8,
		hrs = 16
	conda:
		"envs/env.yaml"
	script:
		"scripts/check_snv_read_data.py"

rule filter_snv_reads:
	input:
		snv_calls = "snv_calls/{sample}_from_{parent}.{region}.snvs.tsv",
		read_data = "read_data/{sample}_from_{parent}.{region}.{platform}.read_data.tsv"
	output:
		platform_validation = "read_data/{sample}_from_{parent}.{region}.{platform}.validation.tsv"
	log:
		"log/filter_reads_{sample}_from_{parent}_{region}_{platform}.log"
	resources:
		mem = 24,
		hrs = 2
	params:
		parent = lambda wildcards: child_dict[f"{wildcards.sample}"].get_parent_id(f"{wildcards.parent}"),
		child = "{sample}",
		platform = "{platform}"
	conda:
		"envs/env.yaml"
	script:
		"scripts/filter_snv_reads.py"


rule validate_snvs:
	input:
		platform_validations = expand("read_data/{{sample}}_from_{{parent}}.{{region}}.{platform}.validation.tsv", platform = platforms)
	output:
		validated_snvs = "validated_calls/{sample}_from_{parent}.{region}.validated_snvs.tsv"
	log:
		"log/validate_{sample}_from_{parent}_{region}_snvs.log"
	resources:
		mem = 24,
		hrs = 2
	conda:
		"envs/env.yaml"
	script:
		"scripts/combine_validations.py"
